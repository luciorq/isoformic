---
title: "Preparing Isoformic Inputs"
author:
  - name: "Izabela Mamede Conceição"
  - name: "Lucio Rezende Queiroz"
date: "2025-10-02"
vignette: >
  %\VignetteIndexEntry{Preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(
  tidy = FALSE, cache = FALSE, dev = "png",
  message = FALSE, error = FALSE, warning = FALSE
)
```

##  Salmon: command command line interface anatomy

### From the Terminal - Salmon Command Line Interface

Below is a single-sample invocation (to be run in a Bash shell) showing the
typical arguments we used when making the mini dataset used in this vignette.

Replace the paths with yours if you want to reproduce.

More thorough information can be found on: <https://combine-lab.github.io/salmon/>.

``` bash
salmon quant \
  --libType A \                      # A -> autodetect library type from the reads
  --index /path/to/index \           # Transcriptome index (here: index built from the FASTA annotation file)
  --mates1 /path/SRR..._1.fastq \    # R1 FASTQ
  --mates2 /path/SRR..._2.fastq \    # R2 FASTQ
  --output /path/SRR..._quant \      # Output folder (contains quant.sf, aux_info/)
  --threads 8 \                      # Number of parallel threads used
  --validateMappings \               # selective-alignment (more specific, recommended)
  --d \                              # Add Terminus needed outputs
  --posBias --seqBias --gcBias \     # bias corrections (positional, sequence, GC)
  --numGibbsSamples 100              # draw inferential replicates; required for fishpond/Swish
```

### From R - Condathis wrapper for Salmon

Caveats: currently Salmon is only available for MacOS and Linux on the [Bioconda](https://bioconda.github.io/) channel.

Therefore, this example will not work natively on Windows.
But you can use WSL2 (Windows Subsystem for Linux) on Windows 10/11 to run it.

```{r, eval=FALSE}
library(condathis)
condathis::create_env(
  package = "salmon",
  env_name = "salmon-env",
  additional_channels = "bioconda"
)

salmon_index <- function(fasta_path, index_path = "salmon_index", kmer_len = 31, num_threads = 8) {
  rlang::check_installed("condathis")
  condathis::run(
    "salmon", "index",
    "--transcripts", fasta_path,
    "--index", index_path,
    "--type", "quasi",
    "--kmerLen", 31,
    "--threads", 8,
    env_name = "salmon-env",
    verbose = "output"
  )
}

salmon_quant <- function(index_path, input_r1, input_r2, output_dir = "quant_output", num_threads = 8, num_gibbs = 100) {
  rlang::check_installed("condathis")
  condathis::run(
    "salmon", "quant",
    "--libType", "A",
    "--index", index_path,
    "--mates1", input_r1,
    "--mates2", input_r2,
    "--output", output_dir,
    "--threads", num_threads,
    "--validateMappings",
    "--d",
    "--posBias",
    "--seqBias",
    "--gcBias",
    "--numGibbsSamples", num_gibbs,
    env_name = "salmon-env",
    verbose = "output"
  )
}

salmon_quant(
  index_path = "/path/to/index",
  input_r1 = "/path/SRR..._1.fastq",
  input_r2 = "/path/SRR..._2.fastq",
  output_dir = "/path/SRR..._quant"
)
```

Now to run and get the isoformic tables.

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(readr)
  library(SummarizedExperiment)
  library(tximeta)
  library(isoformic)
  library(fishpond)
  library(tximport)
  library(DESeq2)
})

library(isoformic)

# Where extdata lives
ext_base <- system.file("extdata", package = "isoformic")
if (ext_base == "") {
  ext_base <- file.path("inst", "extdata")
}

ext_base <- "data-raw/mini_data"

# TODO: @luciorq This step requires the git LFS command
# + Run `git lfs pull`
quants_dir <- file.path(ext_base, "mini_quants")

gff_path <- isoformic::download_reference(version = "34", file_type = "gff")

fasta_path <- isoformic::download_reference(version = "34", file_type = "fasta")

tx_to_gene <- make_tx_to_gene(
  file_path = fasta_path,
  file_type = "fasta"
)

head(tx_to_gene)

tx2gene <- tx_to_gene |>
  dplyr::select(transcript_id, gene_name)
head(tx2gene)
```

## Load Salmon Quantification with tximeta

Point to Salmon's `quant.sf` output files.

```{r}
# discover sample folders like SRR11498039_quant, etc.
sample_dirs <- list.dirs(quants_dir, full.names = FALSE, recursive = FALSE)

# keep only *_quant and strip the suffix for sample names
samples <- sub("_quant$", "", sample_dirs)
stopifnot(length(samples) == 6)

# define groups: "control" = first 3, "treatment" = last 3 (sorted by sample ID)
samples <- sort(samples)
condition <- c(rep("control", 3), rep("treatment", 3))

files <- file.path(quants_dir, paste0(samples, "_quant"), "quant.sf")
names(files) <- samples
stopifnot(all(file.exists(files)))

coldata <- tibble::tibble(
  files = files,
  names = samples,
  condition = factor(condition, levels = c("control", "treatment"))
)
coldata
```

Import transcriptomics data with tximeta.

```{r}
str(se_tx)
se_tx <- tximeta::tximeta(coldata, skipMeta = TRUE)
```

```{r, eval=FALSE}
# write_rds(se_tx, "data-raw/se_tx.rds")
# se_tx <- readr::read_rds("data-raw/se_tx.rds")

lobstr::obj_sizes(se_tx)
se_tx2 <- se_tx
rownames(se_tx2) <- stringr::str_remove(rownames(se_tx), "\\|.*")
lobstr::obj_sizes(se_tx2)

class(rownames(se_tx))
class(rownames(se_tx2))
head(rownames(se_tx))
head(rownames(se_tx2))
write_rds(se_tx, "data-raw/se_tx.rds", compress = "xz")
write_rds(se_tx2, "data-raw/se_tx2.rds", compress = "xz")

waldo::compare(se_tx, se_tx2)
se_tx <- se_tx2
```

Save the counts table.

```{r}
tx_counts_df <- se_tx |>
  assay("counts") |>
  as.data.frame() |>
  tibble::rownames_to_column("transcript_id") |>
  as_tibble() |>
  dplyr::left_join(tx2gene, by = "transcript_id") |>
  dplyr::relocate("gene_name", .after = "transcript_id")

tx_counts_df
```

Perform transcript-level Differential Expression Analysis with fishpond.

```{r}
y <- se_tx
y <- fishpond::scaleInfReps(y)

y <- fishpond::labelKeep(y, minCount = 10, minN = 3)
y <- y[mcols(y)$keep, ]

y$condition <- factor(y$condition, levels = c("control", "case"))

# run Swish
y <- fishpond::swish(y, x = "condition")

str(y)
```

```{r}
# collect results
DET_all <- S4Vectors::mcols(y) |>
  as.data.frame() |>
  tibble::rownames_to_column("transcript_id") |>
  as_tibble() |>
  dplyr::left_join(tx2gene, by = "transcript_id")

DET_all
```

Perform Gene level Differential Expression with DESeq2.

```{r}
# colData(se_tx)

# colData(se_gene)

if (rlang::is_installed("apeglm")) {
  message("apeglm is installed")
} else {
  message("apeglm is NOT installed")
}
rlang::check_installed("apeglm")
# library(apeglm)

se_gene <- tximeta::summarizeToGene(se_tx, tx2gene = dplyr::select(tx2gene, transcript_id, gene_name), skipRanges = TRUE)
colData(se_gene)$condition <- factor(colData(se_gene)$condition, levels = c("control", "treatment"))

dds <- DESeq2::DESeqDataSet(se_gene, design = ~condition)
dds <- dds[rowSums(DESeq2::counts(dds) >= 10) >= 3, ]
dds <- DESeq2::DESeq(dds)

res <- DESeq2::results(dds, contrast = c("condition", "treatment", "control"))

# shrink for stability on small example
res_shr <- DESeq2::lfcShrink(dds, coef = "condition_treatment_vs_control", res = res, type = "apeglm")

DEG_all <- as.data.frame(res_shr) |>
  tibble::rownames_to_column("gene_id") |>
  as_tibble()

DEG_all
```
